<html>

<head>

    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta http-equiv="ScreenOrientation" content="autoRotate:disabled">
    <meta name="apple-mobile-web-app-capable" content="yes" />

    <script src="../../../libs/DemoFramework2.js" type="text/javascript"></script>
    <script src="../../../libs/MathHelperFunctions.js" type="text/javascript"></script>
    <script src="../../../libs/DrawingHelperFunctions.js" type="text/javascript"></script>

    <title></title>

    <style type="text/css">
        body {
            background-color: black;
        }

        canvas {
            border: 1px solid #ccc;
            width: 100%;
        }
    </style>
</head>

<body>
    <canvas id="canvas" width="300" height="300"></canvas>
</body>

<script type="text/javascript">

    // original idea from: https://www.dwitter.net/d/17588
    // c.style.filter="blur(1vh)invert(1";for(c.width|=j=21,x.scale(9,9);j--;)for(i=99;i--;)x.arc(0,0,1.3**(j+i%2+t%2),a=(i+j)%24/4,a);x.stroke()

    /// Settings ////////////////////////////////////////////

    // put any adjustable settings here that would be interesting to tinker with.

    var CANVAS_WIDTH = 800;
    var CANVAS_HEIGHT = 800;
    var FPS = 60;
    var SETTINGS_PACKAGE = {
        ANIMATION_SPEED_DIVISOR: {
            Min: 10000,
            Max: 20000
        }
    };

    /////////////////////////////////////////////////////////

    var localCtxReference = undefined;
    var lastTime = 0;
    var date = undefined;
    var elapsed = 0;

    var pointCount = undefined;
    var size = undefined;
    var shapes = undefined;

    // code to run before update looping starts.

    function init(params) {

        return new Promise(
            function (resolve, reject) {

                console.log("Init");
                lastTime = Math.floor(Math.random() * 10000000);
                elapsed = Math.random() * 10000;

                params.ctx.lineWidth = "2";
                params.ctx.strokeStyle = "rgba(255, 255, 255, 1)";

                pointCount = 100;
                size = 500;
                var x = Math.floor(CANVAS_WIDTH / 2);
                var y = Math.floor(CANVAS_HEIGHT / 2);

                shapes = [
                    generateCirclePoints(pointCount, x, y, size),
                    generateSquarePoints(pointCount, x - (size / 2), y - (size / 2), size, size, 0)/*,
                    generateTrianglePoints(pointCount, x - (size / 2), y - (size / 2), size, size, 0)*/
                ];

                console.log("Points generated", ...shapes.map(shape => shape.length));

                resolve({
                    fps: FPS
                });
            });
    }

    function randomizeArray(a, b) {
        return Math.random() > 0.5 ? 1 : -1;
    }

    var interpolatedArray = undefined;

    // code to run every frame.
    function update(params) {

        date = new Date();
        elapsed += date - lastTime;
        lastTime = date;

        params.ctx.fillStyle = "rgba(0, 0, 0, 0.04)";
        params.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        interpolatedArray = [];

        for (i = 0; i < shapes[0].length; i++) {
            interpolatedArray.push(
                interpolateMultiplePoints(
                    (Math.cos(elapsed / 2000) + 1) * 0.5,
                    ...shapes.map(shape => shape[i])));
        }

        drawPoints(params.ctx, interpolatedArray, "#fff");
    }

    function interpolateMultiplePoints(amount, ...points) {
        var interpolationSegmentLengths = (1 / points.length) + 0.01;
        var pSeg1 = Math.floor(amount / interpolationSegmentLengths);
        var pSeg2 = pSeg1 === (points.length - 1) ? 0 : pSeg1 + 1;

        while (amount > interpolationSegmentLengths) {
            amount -= interpolationSegmentLengths;
        }

        var segAmount = amount / interpolationSegmentLengths;

        return {
            x: points[pSeg1].x + ((points[pSeg2].x - points[pSeg1].x) * segAmount),
            y: points[pSeg1].y + ((points[pSeg2].y - points[pSeg1].y) * segAmount)
        };
    }

    function drawPoints(ctx, arr, color) {
        ctx.strokeStyle = color;
        for (var i = 0; i < arr.length; i++) {
            ctx.beginPath();
            var v = arr[i];
            var v2 = arr[i === arr.length - 1 ? 0 : i + 1];
            ctx.moveTo(v.x, v.y);
            ctx.lineTo(v2.x, v2.y);
            ctx.stroke();
        }
    }

    function generateCirclePoints(points, x, y, radius) {
        var result = [];
        var radiansPerPoint = (360 / points) * (Math.PI / 180);

        for (var i = 0; i < points; i++) {
            result.push({
                x: x + (Math.cos(i * radiansPerPoint) * radius / 2),
                y: y + (Math.sin(i * radiansPerPoint) * radius / 2)
            });
        }

        return result;
    }

    function generateTrianglePoints(points, x, y, width, height, rotationDegrees) {
        var corners = [];

        corners.push({
            x: MathHelperFunctions.RotatePoint(x + (width / 2), y + (height / 2), x + width / 2, y, rotationDegrees)[0],
            y: MathHelperFunctions.RotatePoint(x + (width / 2), y + (height / 2), x + width / 2, y, rotationDegrees)[1]
        });

        corners.push({
            x: MathHelperFunctions.RotatePoint(x + (width / 2), y + (height / 2), x + width, y + height, rotationDegrees)[0],
            y: MathHelperFunctions.RotatePoint(x + (width / 2), y + (height / 2), x + width, y + height, rotationDegrees)[1]
        });

        corners.push({
            x: MathHelperFunctions.RotatePoint(x + (width / 2), y + (height / 2), x, y + height, rotationDegrees)[0],
            y: MathHelperFunctions.RotatePoint(x + (width / 2), y + (height / 2), x, y + height, rotationDegrees)[1]
        });

        var result = [
            ...DrawingHelperFunctions.BreakLineIntoSteps(
                corners[0].x,
                corners[0].y,
                corners[1].x,
                corners[1].y,
                Math.floor(points / 3)
            ),
            ...DrawingHelperFunctions.BreakLineIntoSteps(
                corners[1].x,
                corners[1].y,
                corners[2].x,
                corners[2].y,
                Math.floor(points / 3)
            ),
            ...DrawingHelperFunctions.BreakLineIntoSteps(
                corners[2].x,
                corners[2].y,
                corners[0].x,
                corners[0].y,
                Math.floor(points / 3)
            )
        ];

        return arrsToXYs([...result, result[result.length - 1]]);
    }

    function generateSquarePoints(points, x, y, width, height, rotationDegrees) {
        var corners = [];

        corners.push({
            x: MathHelperFunctions.RotatePoint(x + (width / 2), y + (height / 2), x, y, rotationDegrees)[0],
            y: MathHelperFunctions.RotatePoint(x + (width / 2), y + (height / 2), x, y, rotationDegrees)[1]
        });

        corners.push({
            x: MathHelperFunctions.RotatePoint(x + (width / 2), y + (height / 2), x + width, y, rotationDegrees)[0],
            y: MathHelperFunctions.RotatePoint(x + (width / 2), y + (height / 2), x + width, y, rotationDegrees)[1]
        });

        corners.push({
            x: MathHelperFunctions.RotatePoint(x + (width / 2), y + (height / 2), x + width, y + height, rotationDegrees)[0],
            y: MathHelperFunctions.RotatePoint(x + (width / 2), y + (height / 2), x + width, y + height, rotationDegrees)[1]
        });

        corners.push({
            x: MathHelperFunctions.RotatePoint(x + (width / 2), y + (height / 2), x, y + height, rotationDegrees)[0],
            y: MathHelperFunctions.RotatePoint(x + (width / 2), y + (height / 2), x, y + height, rotationDegrees)[1]
        });

        var result = [
            ...DrawingHelperFunctions.BreakLineIntoSteps(
                corners[0].x,
                corners[0].y,
                corners[1].x,
                corners[1].y,
                Math.floor(points / 4)
            ),
            ...DrawingHelperFunctions.BreakLineIntoSteps(
                corners[1].x,
                corners[1].y,
                corners[2].x,
                corners[2].y,
                Math.floor(points / 4)
            ),
            ...DrawingHelperFunctions.BreakLineIntoSteps(
                corners[2].x,
                corners[2].y,
                corners[3].x,
                corners[3].y,
                Math.floor(points / 4)
            ),
            ...DrawingHelperFunctions.BreakLineIntoSteps(
                corners[3].x,
                corners[3].y,
                corners[0].x,
                corners[0].y,
                Math.floor(points / 4))
        ];

        return arrsToXYs(result);
    }

    function arrsToXYs(arrayOfArrays) {
        return arrayOfArrays.map(function (p) { return { x: p[0], y: p[1] } });
    }

</script>

</html>